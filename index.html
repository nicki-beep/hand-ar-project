<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Architect OS - Video Enabled</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        /* This makes the camera video visible and mirrored behind the 3D blocks */
        #video {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            object-fit: cover; transform: scaleX(-1); z-index: -1;
        }
        #os-ui {
            position: fixed; top: 20px; left: 20px; color: #00ff00; z-index: 10;
            background: rgba(0, 40, 0, 0.6); padding: 15px; border: 1px solid #00ff00;
            pointer-events: none; text-transform: uppercase;
        }
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; color: #00ff00;
        }
        #start-btn {
            padding: 15px 30px; font-size: 18px; background: transparent;
            color: #00ff00; border: 2px solid #00ff00; cursor: pointer;
            visibility: hidden;
        }
        .ready { visibility: visible !important; }
        canvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>

<div id="start-overlay">
    <div id="loading-text">BIO_SYNC: LOADING MODEL...</div>
    <button id="start-btn">BOOT ARCHITECT_OS</button>
</div>

<div id="os-ui">
    BIO_SYNC: ARCHITECT_OS_v4.1<br>
    STATE: <span id="state">IDLE</span><br>
    VOXELS: <span id="count">0</span>
</div>

<video id="video" autoplay playsinline></video>

<script>
let scene, camera, renderer, previewBlock, blocks = [];
let canAction = true;
const GRID = 0.25;

// 1. THREE.JS SETUP WITH TRANSPARENCY
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 2;

renderer = new THREE.WebGLRenderer({ 
    alpha: true, // This allows the video to show through the background
    antialias: true 
});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 1.2));

const boxGeo = new THREE.BoxGeometry(GRID, GRID, GRID);
previewBlock = new THREE.Mesh(boxGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true }));
scene.add(previewBlock);

// 2. AI HANDS
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.7 });

const startBtn = document.getElementById('start-btn');
hands.initialize().then(() => {
    document.getElementById('loading-text').innerText = "SYSTEM READY";
    startBtn.classList.add('ready');
});

hands.onResults(results => {
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
    
    const lm = results.multiHandLandmarks[0];
    const index = lm[8];
    const thumb = lm[4];

    const pinch = Math.hypot(index.x - thumb.x, index.y - thumb.y) < 0.05;
    const palmOpen = Math.hypot(lm[8].y - lm[0].y) > 0.3;

    // Use mirrored coordinates to match the video
    let x = (index.x - 0.5) * 4; 
    let y = -(index.y - 0.5) * 3;
    x = Math.round(x / GRID) * GRID;
    y = Math.round(y / GRID) * GRID;
    previewBlock.position.set(x, y, -1);

    if (pinch && canAction) {
        const voxel = new THREE.Mesh(boxGeo, new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
        voxel.position.set(x, y, -1);
        scene.add(voxel);
        blocks.push(voxel);
        updateUI("PLACING", blocks.length);
        cooldown();
    } else if (palmOpen && canAction && blocks.length > 0) {
        scene.remove(blocks.pop());
        updateUI("DELETING", blocks.length);
        cooldown();
    }
});

function cooldown() {
    canAction = false;
    setTimeout(() => { canAction = true; document.getElementById('state').innerText = "ACTIVE"; }, 600);
}

function updateUI(s, c) {
    document.getElementById('state').innerText = s;
    document.getElementById('count').innerText = c;
}

// 3. START
startBtn.onclick = () => {
    document.getElementById('start-overlay').style.display = 'none';
    const cam = new Camera(document.getElementById("video"), {
        onFrame: async () => await hands.send({ image: document.getElementById("video") }),
        width: 1280, height: 720
    });
    cam.start();
};

function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
animate();
</script>
</body>
</html>
