<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Master Architect OS</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #video { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: -1; }
        #os-ui { position: fixed; top: 20px; left: 20px; color: #00ff00; z-index: 10; background: rgba(0, 40, 0, 0.7); padding: 15px; border: 1px solid #00ff00; pointer-events: none; font-size: 14px; }
        #start-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: #00ff00; }
        #start-btn { padding: 15px 30px; font-size: 18px; background: transparent; color: #00ff00; border: 2px solid #00ff00; cursor: pointer; visibility: hidden; }
        .ready { visibility: visible !important; }
    </style>
</head>
<body>

<div id="start-overlay">
    <div id="loading-text">BIO_SYNC: LOADING MASTER_OS...</div>
    <button id="start-btn">INITIALIZE ARCHITECT</button>
</div>

<div id="os-ui">
    STATUS: <span id="state">ACTIVE</span><br>
    ------------------------------------<br>
    ü§è PINCH: PLACE | ‚úä FIST: MOVE BUILD<br>
    ‚úä‚úä TWO FISTS: ROTATE WORLD<br>
    ‚úã OPEN PALM: MAGIC SHIELD<br>
    ‚úåÔ∏è+THUMB: FLAME THROWER<br>
    üîÑ ROTATE RIGHT: SNOW ON / LEFT: OFF<br>
    üôè PALMS TOGETHER: RESET WORLD
</div>

<video id="video" autoplay playsinline></video>

<script>
let scene, camera, renderer, worldGroup, snowParticles = null;
let blocks = [], flames = [], canAction = true, isSnowing = false;
const GRID = 0.25;

// 1. SCENE SETUP
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 2;
renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff, 1.2));

worldGroup = new THREE.Group();
scene.add(worldGroup);

// MAGIC SHIELD (Using your uploaded design style)
const shieldGeo = new THREE.RingGeometry(0.3, 0.45, 32);
const shieldMat = new THREE.MeshBasicMaterial({ color: 0xff4500, side: THREE.DoubleSide, transparent: true, opacity: 0.7, wireframe: true });
const shieldL = new THREE.Mesh(shieldGeo, shieldMat);
const shieldR = new THREE.Mesh(shieldGeo, shieldMat);
scene.add(shieldL, shieldR);

// 2. GESTURE SYSTEMS
function toggleSnow(state) {
    if (state && !isSnowing) {
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<800; i++) pos.push((Math.random()-0.5)*10, Math.random()*5, (Math.random()-0.5)*10);
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        snowParticles = new THREE.Points(geo, new THREE.PointsMaterial({color: 0xffffff, size: 0.04}));
        scene.add(snowParticles);
        isSnowing = true;
    } else if (!state && isSnowing) {
        scene.remove(snowParticles);
        isSnowing = false;
    }
}

function createFlame(x, y) {
    const f = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshBasicMaterial({color: 0xff2200}));
    f.position.set(x, y, -0.8);
    scene.add(f);
    flames.push({obj: f, life: 1.0, vx: (Math.random()-0.5)*0.02});
}

// 3. AI HAND TRACKING
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.6 });

let lastPos = null;

hands.onResults(results => {
    shieldL.visible = shieldR.visible = false;
    if (!results.multiHandLandmarks) return;

    let fists = [];

    // üôè RESET GESTURE
    if (results.multiHandLandmarks.length === 2) {
        const h1 = results.multiHandLandmarks[0][0], h2 = results.multiHandLandmarks[1][0];
        if (Math.hypot(h1.x-h2.x, h1.y-h2.y) < 0.08) {
            blocks.forEach(b => worldGroup.remove(b));
            blocks = []; toggleSnow(false);
            worldGroup.position.set(0,0,0); worldGroup.rotation.set(0,0,0);
        }
    }

    results.multiHandLandmarks.forEach((lm, i) => {
        const isRight = results.multiHandedness[i].label === "Right";
        const wrist = lm[0], thumb = lm[4], idx = lm[8], mid = lm[12], ring = lm[16], pky = lm[20];
        
        const x = (idx.x - 0.5) * 4;
        const y = -(idx.y - 0.5) * 3;

        const isFist = Math.hypot(idx.x-wrist.x, idx.y-wrist.y) < 0.12;
        const isShield = Math.hypot(mid.y - wrist.y) > 0.3;
        const pinch = Math.hypot(idx.x-thumb.x, idx.y-thumb.y) < 0.05;
        const isFlame = Math.hypot(idx.y-mid.y) < 0.05 && thumb.x > idx.x;

        if (isFist) fists.push({x, y});

        // ACTION: SNOW ROTATION
        const angle = Math.atan2(thumb.y - wrist.y, thumb.x - wrist.x);
        if (isRight) {
            if (angle > 0.7) toggleSnow(true);
            if (angle < -0.7) toggleSnow(false);
        }

        // ACTION: SHIELD
        if (isShield && !isFist) {
            const s = isRight ? shieldR : shieldL;
            s.visible = true; s.position.set(x, y, -0.5); s.rotation.z += 0.05;
        }

        // ACTION: FLAME
        if (isFlame) createFlame(x, y);

        // ACTION: PLACE BLOCK
        if (pinch && canAction && !isFist) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(GRID, GRID, GRID), new THREE.MeshStandardMaterial({color: 0x00ff00}));
            b.position.set(Math.round(x/GRID)*GRID - worldGroup.position.x, Math.round(y/GRID)*GRID - worldGroup.position.y, -1);
            worldGroup.add(b); blocks.push(b);
            canAction = false; setTimeout(() => canAction = true, 500);
        }

        // ACTION: MANIPULATION
        if (fists.length === 1 && isFist) {
            worldGroup.position.x += (x - (lastPos?.x || x)) * 0.8;
            worldGroup.position.y += (y - (lastPos?.y || y)) * 0.8;
        } else if (fists.length === 2) {
            worldGroup.rotation.y += 0.03;
        }
        lastPos = {x, y};
    });
});

// 4. ANIMATION LOOP
function animate() {
    requestAnimationFrame(animate);
    if (isSnowing && snowParticles) {
        snowParticles.position.y -= 0.02;
        if (snowParticles.position.y < -3) snowParticles.position.y = 2;
    }
    flames.forEach((f, i) => {
        f.obj.position.y += 0.04; f.obj.position.x += f.vx;
        f.life -= 0.03; f.obj.scale.set(f.life, f.life, f.life);
        if (f.life <= 0) { scene.remove(f.obj); flames.splice(i, 1); }
    });
    renderer.render(scene, camera);
}
animate();

const startBtn = document.getElementById('start-btn');
hands.initialize().then(() => startBtn.classList.add('ready'));
startBtn.onclick = () => {
    document.getElementById('start-overlay').style.display = 'none';
    new Camera(document.getElementById("video"), { onFrame: async () => await hands.send({image: video}), width: 1280, height: 720 }).start();
};
</script>
</body>
</html>
