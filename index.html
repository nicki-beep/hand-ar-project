<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Architect OS - True Mirror</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Helvetica', sans-serif; }
        
        /* MIRROR THE VIDEO AND THE OVERLAY CANVAS */
        #video, #drawing_canvas { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
            object-fit: cover; transform: scaleX(-1); 
        }
        
        #video { z-index: -1; filter: grayscale(1) contrast(1.2); }
        #drawing_canvas { z-index: 1; pointer-events: none; }

        /* CRT SCANLINE EFFECT */
        body::after {
            content: " "; display: block; position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 20; background-size: 100% 3px, 2px 100%; pointer-events: none;
        }

        #ui-overlay {
            position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: #fff; text-align: center; z-index: 30; letter-spacing: 3px; pointer-events: none;
        }
        #start-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; z-index: 100; }
        #start-btn { background: #fff; border: none; padding: 15px 30px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

<div id="start-screen"><button id="start-btn">INITIALIZE MIRROR_OS</button></div>

<div id="ui-overlay">
    <div id="color-label" style="font-size: 20px; font-weight: 900; color: #00ff00;">MODE: GREEN</div>
    <div style="font-size: 10px; opacity: 0.6; margin-top: 5px;">VOXELS: <span id="count">0</span></div>
</div>

<video id="video" autoplay playsinline></video>
<canvas id="drawing_canvas"></canvas>

<script>
let scene, camera, renderer, worldGroup, previewBlock, blocks = [];
let canAction = true, canColorChange = true;
const GRID = 0.22;

const colors = [0x00FF00, 0x0066FF, 0xFF0033, 0x9900FF, 0xFF9900];
const colorNames = ["GREEN", "BLUE", "RED", "PURPLE", "ORANGE"];
let colorIdx = 0;

// 1. THREE.JS SETUP
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 5;

renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

worldGroup = new THREE.Group();
scene.add(worldGroup);

scene.add(new THREE.AmbientLight(0xffffff, 1.5));

// Ghost Preview
const boxGeo = new THREE.BoxGeometry(GRID, GRID, GRID);
previewBlock = new THREE.Mesh(boxGeo, new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, wireframe: true }));
scene.add(previewBlock);

// 2. HAND TRACKING
const drawCanvas = document.getElementById('drawing_canvas');
const drawCtx = drawCanvas.getContext('2d');
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });

hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8 });

let lastFistPos = null;

hands.onResults(results => {
    drawCanvas.width = window.innerWidth;
    drawCanvas.height = window.innerHeight;
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

    if (!results.multiHandLandmarks) return;

    let fists = [];
    results.multiHandLandmarks.forEach((lm, i) => {
        // DRAW MIRRORED OUTLINE
        drawConnectors(drawCtx, lm, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
        drawLandmarks(drawCtx, lm, {color: '#FFFFFF', radius: 2});

        const wrist = lm[0], thumb = lm[4], idx = lm[8], mid = lm[12];
        
        // --- THE MIRROR FIX ---
        // We flip the X coordinate here so the 3D world matches the mirrored video
        const x = ((1 - idx.x) - 0.5) * 8; 
        const y = -(idx.y - 0.5) * 5;

        const isFist = Math.hypot(idx.x-wrist.x, idx.y-wrist.y) < 0.12;
        const pinch = Math.hypot(idx.x-thumb.x, idx.y-thumb.y) < 0.04;
        const isPeace = Math.hypot(idx.y-mid.y) < 0.06 && idx.y < wrist.y;
        const isPalm = Math.hypot(idx.y-wrist.y) > 0.35;

        // GESTURE: COLOR CYCLE (âœŒï¸)
        if (isPeace && canColorChange) {
            colorIdx = (colorIdx + 1) % colors.length;
            document.getElementById('color-label').innerText = "MODE: " + colorNames[colorIdx];
            document.getElementById('color-label').style.color = '#' + colors[colorIdx].toString(16).padStart(6, '0');
            canColorChange = false; setTimeout(() => canColorChange = true, 600);
        }

        if (isFist) fists.push({x, y});

        // GESTURE: HOLD & MOVE (âœŠ)
        if (fists.length === 1 && isFist) {
            if (lastFistPos) {
                worldGroup.position.x += (x - lastFistPos.x);
                worldGroup.position.y += (y - lastFistPos.y);
            }
            lastFistPos = {x, y};
        } else if (fists.length === 2) {
            worldGroup.rotation.y += 0.05; // 360 ROTATE
        } else {
            lastFistPos = null;
        }

        // GESTURE: PLACE (ðŸ¤)
        if (pinch && canAction && !isFist) {
            const b = new THREE.Mesh(boxGeo, new THREE.MeshPhongMaterial({ color: colors[colorIdx] }));
            const vector = new THREE.Vector3(Math.round(x/GRID)*GRID, Math.round(y/GRID)*GRID, 0);
            worldGroup.worldToLocal(vector);
            b.position.copy(vector);
            b.scale.set(0,0,0);
            worldGroup.add(b); blocks.push(b);
            document.getElementById('count').innerText = blocks.length;
            canAction = false; setTimeout(() => canAction = true, 400);
        }

        // GESTURE: ERASE (âœ‹)
        if (isPalm && !isFist && blocks.length > 0 && canAction) {
            worldGroup.remove(blocks.pop());
            document.getElementById('count').innerText = blocks.length;
            canAction = false; setTimeout(() => canAction = true, 400);
        }

        if (i === 0) previewBlock.position.set(Math.round(x/GRID)*GRID, Math.round(y/GRID)*GRID, 0);
    });
});

// 3. START & ANIMATE
function animate() {
    requestAnimationFrame(animate);
    blocks.forEach(b => {
        if (b.scale.x < 1) b.scale.lerp(new THREE.Vector3(1, 1, 1), 0.2);
    });
    renderer.render(scene, camera);
}
animate();

document.getElementById('start-btn').onclick = () => {
    document.getElementById('start-overlay') || document.getElementById('start-screen').style.display = 'none';
    new Camera(document.getElementById("video"), {
        onFrame: async () => await hands.send({image: video}),
        width: 1280, height: 720
    }).start();
};
</script>
</body>
</html>
