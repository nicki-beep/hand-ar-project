<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Fixed Black Screen AR</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        canvas { width: 100vw; height: 100vh; transform: scaleX(-1); }
        #loading-ui { position: absolute; color: white; font-family: sans-serif; text-align: center; }
        button { padding: 20px 40px; font-size: 20px; cursor: pointer; background: #28a745; color: white; border: none; border-radius: 10px; }
    </style>
</head>
<body>
    <div id="loading-ui">
        <button id="start-btn">ENABLE CAMERA</button>
        <p id="status"></p>
    </div>
    <video id="input_video" style="display:none" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const status = document.getElementById('status');
        const startBtn = document.getElementById('start-btn');

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1 });

        hands.onResults((results) => {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // This line forces the camera image to draw even if tracking hasn't started
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 5});
                }
            }
            canvasCtx.restore();
        });

        startBtn.onclick = async () => {
            startBtn.style.display = 'none';
            status.innerText = "Loading AI... Please wait 5-10 seconds";
            
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280, height: 720
            });
            
            try {
                await camera.start();
                // Force video play in case it's stuck
                videoElement.play(); 
            } catch (e) {
                status.innerText = "Error: " + e.message;
            }
        };
    </script>
</body>
</html>
