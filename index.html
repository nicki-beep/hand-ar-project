<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Architect OS - Precision Mirror</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #video { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: -1; }
        #os-ui { position: fixed; top: 20px; left: 20px; color: #00ff00; z-index: 10; background: rgba(0, 40, 0, 0.8); padding: 15px; border: 2px solid #00ff00; pointer-events: none; min-width: 200px; }
        #start-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: #00ff00; }
        #start-btn { padding: 15px 30px; font-size: 18px; background: transparent; color: #00ff00; border: 2px solid #00ff00; cursor: pointer; visibility: hidden; }
        .ready { visibility: visible !important; }
        canvas#drawing_canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; transform: scaleX(-1); pointer-events: none; }
    </style>
</head>
<body>

<div id="start-overlay">
    <div id="loading-text">SYSTEM_SYNC: MIRROR CALIBRATION...</div>
    <button id="start-btn">BOOT ARCHITECT</button>
</div>

<div id="os-ui">
    GESTURE: <span id="gesture-name" style="color:white">SCANNING...</span><br>
    COLOR: <span id="color-name" style="color:white">GREEN</span><br>
    -------------------------<br>
    ü§è PINCH (1s): PLACE<br>
    ‚úåÔ∏è FLICK (1s): COLOR<br>
    ‚úä 1 FIST: HOLD | ‚úã PALM: ERASE
</div>

<video id="video" autoplay playsinline></video>
<canvas id="drawing_canvas"></canvas>

<script>
let scene, camera, renderer, worldGroup, previewBlock, blocks = [];
let gestureTimer = 0, lastGesture = null, colorIdx = 0;
const GRID = 0.25;
const colors = [0x00ff00, 0x0000ff, 0xff0000, 0x800080, 0xffa500];
const colorNames = ["GREEN", "BLUE", "RED", "PURPLE", "ORANGE"];

// 1. THREE.JS SETUP
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 3;
renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff, 1.2));

worldGroup = new THREE.Group();
scene.add(worldGroup);

previewBlock = new THREE.Mesh(new THREE.BoxGeometry(GRID, GRID, GRID), new THREE.MeshBasicMaterial({ color: colors[0], wireframe: true }));
scene.add(previewBlock);

// 2. HAND TRACKING SETUP
const drawCanvas = document.getElementById('drawing_canvas');
const drawCtx = drawCanvas.getContext('2d');
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.8 });

let lastFistPos = null;

hands.onResults(results => {
    drawCanvas.width = window.innerWidth;
    drawCanvas.height = window.innerHeight;
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        document.getElementById('gesture-name').innerText = "NONE";
        gestureTimer = 0; lastGesture = null;
        return;
    }

    const landmarks = results.multiHandLandmarks;
    let currentGesture = "NONE";

    landmarks.forEach((lm, i) => {
        drawConnectors(drawCtx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
        
        const wrist = lm[0], thumb = lm[4], idx = lm[8], mid = lm[12], pky = lm[20];
        
        // MIRROR CORRECTION: Removing the '-' ensures true mirror behavior
        const x = (idx.x - 0.5) * 5; 
        const y = -(idx.y - 0.5) * 3;

        // Gesture Logic
        const isFist = Math.hypot(idx.x-wrist.x, idx.y-wrist.y) < 0.15;
        const isPalm = Math.hypot(idx.y-wrist.y) > 0.35;
        const isPinching = Math.hypot(idx.x-thumb.x, idx.y-thumb.y) < 0.04;
        const isFlicking = Math.hypot(idx.y-mid.y) < 0.08 && idx.y < wrist.y;

        if (isFist) currentGesture = "HOLD";
        else if (isPinching) currentGesture = "PINCH";
        else if (isFlicking) currentGesture = "FLICK";
        else if (isPalm) currentGesture = "ERASE";

        // Logic for Delayed Action (Loading Circle)
        if (currentGesture === "PINCH" || currentGesture === "FLICK") {
            if (lastGesture === currentGesture) {
                gestureTimer += 0.025; // Roughly 1 second total (40 frames)
                drawLoadingCircle(idx.x * drawCanvas.width, idx.y * drawCanvas.height, gestureTimer);
                
                if (gestureTimer >= 1) {
                    executeGesture(currentGesture, x, y);
                    gestureTimer = 0;
                }
            } else {
                gestureTimer = 0;
                lastGesture = currentGesture;
            }
        } else {
            gestureTimer = 0;
            lastGesture = currentGesture;
        }

        // Immediate Gestures
        if (currentGesture === "HOLD") {
            if (lastFistPos) {
                worldGroup.position.x += (x - lastFistPos.x);
                worldGroup.position.y += (y - lastFistPos.y);
            }
            lastFistPos = {x, y};
        } else {
            lastFistPos = null;
        }

        if (currentGesture === "ERASE" && blocks.length > 0) {
            scene.remove(blocks.pop());
            worldGroup.remove(worldGroup.children[worldGroup.children.length-1]);
        }

        // Preview Sync
        if (i === 0) previewBlock.position.set(Math.round(x/GRID)*GRID, Math.round(y/GRID)*GRID, -1);
    });

    document.getElementById('gesture-name').innerText = currentGesture;
});

function drawLoadingCircle(x, y, progress) {
    drawCtx.beginPath();
    drawCtx.arc(x, y, 40, 0, Math.PI * 2 * progress);
    drawCtx.strokeStyle = "#00FF00";
    drawCtx.lineWidth = 8;
    drawCtx.stroke();
}

function executeGesture(type, x, y) {
    if (type === "PINCH") {
        const b = new THREE.Mesh(new THREE.BoxGeometry(GRID, GRID, GRID), new THREE.MeshStandardMaterial({color: colors[colorIdx]}));
        const vector = new THREE.Vector3(Math.round(x/GRID)*GRID, Math.round(y/GRID)*GRID, -1);
        worldGroup.worldToLocal(vector);
        b.position.copy(vector);
        worldGroup.add(b); blocks.push(b);
    } else if (type === "FLICK") {
        colorIdx = (colorIdx + 1) % colors.length;
        previewBlock.material.color.setHex(colors[colorIdx]);
        document.getElementById('color-name').innerText = colorNames[colorIdx];
    }
}

// BOOT ENGINE
const startBtn = document.getElementById('start-btn');
hands.initialize().then(() => startBtn.classList.add('ready'));
startBtn.onclick = () => {
    document.getElementById('start-overlay').style.display = 'none';
    new Camera(document.getElementById("video"), { onFrame: async () => await hands.send({image: document.getElementById("video")}), width: 1280, height: 720 }).start();
};
function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
animate();
</script>
</body>
</html>
