<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Architect OS - Sorcerer Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #video { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: -1; }
        #os-ui { position: fixed; top: 20px; left: 20px; color: #ffae00; z-index: 10; background: rgba(40, 20, 0, 0.7); padding: 15px; border: 1px solid #ffae00; pointer-events: none; font-size: 11px; line-height: 1.4; }
        #start-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: #ffae00; }
        #start-btn { padding: 15px 30px; font-size: 18px; background: transparent; color: #ffae00; border: 2px solid #ffae00; cursor: pointer; visibility: hidden; }
        .ready { visibility: visible !important; }
    </style>
</head>
<body>

<div id="start-overlay">
    <div id="loading-text">MYSTIC_OS: SYNCING RELICS...</div>
    <button id="start-btn">BEGIN INCANTATION</button>
</div>

<div id="os-ui">
    MYSTIC_OS v5.0<br>
    -----------------------------------<br>
    ü§è PINCH INDEX: PLACE BLOCK<br>
    ‚úã SINGLE PALM: ERASER MODE<br>
    üëê TWO PALMS: ELDRITCH SHIELDS<br>
    ‚úåÔ∏è TWO FINGERS (BOTH): FIRE CONTROL<br>
    üåÄ ROTATE RIGHT SHIELD: SUMMON SNOW
</div>

<video id="video" autoplay playsinline></video>

<script>
let scene, camera, renderer, previewBlock, blocks = [], worldGroup;
let canAction = true;
let leftShield, rightShield, fireL, fireR, snowSystem;

// 1. SCENE SETUP
scene = new THREE.Scene();
worldGroup = new THREE.Group();
scene.add(worldGroup);
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 2.5;
renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff, 1.0));

// 2. MYSTIC ASSETS
const shieldGeo = new THREE.RingGeometry(0.2, 0.25, 32);
const shieldMat = new THREE.MeshBasicMaterial({ color: 0xff4400, side: THREE.DoubleSide, transparent: true, opacity: 0 });
leftShield = new THREE.Mesh(shieldGeo, shieldMat);
rightShield = new THREE.Mesh(shieldGeo, shieldMat.clone());
scene.add(leftShield, rightShield);

const fireGeo = new THREE.SphereGeometry(0.1, 8, 8);
const fireMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 });
fireL = new THREE.Mesh(fireGeo, fireMat);
fireR = new THREE.Mesh(fireGeo, fireMat.clone());
scene.add(fireL, fireR);

const snowGeo = new THREE.BufferGeometry();
const snowCount = 1000;
const posArray = new Float32Array(snowCount * 3);
for(let i=0; i<snowCount*3; i++) posArray[i] = (Math.random()-0.5)*10;
snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({ size: 0.02, color: 0xffffff, transparent:true, opacity:0 }));
scene.add(snowSystem);

const GRID = 0.2;
previewBlock = new THREE.Mesh(new THREE.BoxGeometry(GRID,GRID,GRID), new THREE.MeshBasicMaterial({ color: 0xffae00, wireframe: true }));
scene.add(previewBlock);

// 3. AI HANDS
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.7 });

hands.initialize().then(() => {
    document.getElementById('loading-text').innerText = "RELICS READY";
    document.getElementById('start-btn').classList.add('ready');
});

hands.onResults(results => {
    const numHands = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
    
    // Hide magical elements by default
    leftShield.material.opacity = 0;
    rightShield.material.opacity = 0;
    fireL.material.opacity = 0;
    fireR.material.opacity = 0;

    if (numHands === 0) return;

    results.multiHandLandmarks.forEach((lm, index) => {
        const isRightHand = results.multiHandedness[index].label === "Right";
        
        // Coordinates (Mirrored)
        const x = -(lm[9].x - 0.5) * 4;
        const y = -(lm[9].y - 0.5) * 3;

        // GESTURE CHECKS
        const palmOpen = Math.hypot(lm[8].y - lm[0].y) > 0.35;
        const isPeace = Math.hypot(lm[8].y - lm[12].y) < 0.1 && lm[8].y < lm[6].y;
        const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.05;

        // 1. ELDRITCH SHIELDS (Both Palms Open)
        if (palmOpen && numHands === 2) {
            const shield = isRightHand ? rightShield : leftShield;
            shield.position.set(x, y, -0.5);
            shield.material.opacity = 0.8;
            shield.rotation.z += 0.1;

            // 2. SNOW SUMMON (Rotate Right Shield)
            if (isRightHand && shield.rotation.z > 5) {
                snowSystem.material.opacity = 0.8;
            }
        }

        // 3. FIRE CONTROL (Peace/Two Fingers Gesture)
        if (isPeace) {
            const fire = isRightHand ? fireR : fireL;
            fire.position.set(x, y, -0.5);
            fire.material.opacity = 1;
            fire.scale.setScalar(1 + Math.sin(Date.now()*0.01)*0.2);
        }

        // 4. ERASER (Single Palm Open)
        if (palmOpen && numHands === 1) {
            previewBlock.material.color.set(0xff0000);
            previewBlock.position.set(x, y, -0.5);
            if (canAction) {
                blocks.forEach((b, i) => {
                    if (Math.hypot(b.position.x - x, b.position.y - y) < 0.3) {
                        worldGroup.remove(b);
                        blocks.splice(i, 1);
                    }
                });
            }
        }

        // 5. BUILDER (Pinch)
        if (pinch && numHands === 1 && !palmOpen) {
            previewBlock.material.color.set(0x00ff00);
            const sx = Math.round(x / GRID) * GRID;
            const sy = Math.round(y / GRID) * GRID;
            previewBlock.position.set(sx, sy, -0.5);
            if (canAction) {
                const b = new THREE.Mesh(new THREE.BoxGeometry(GRID,GRID,GRID), new THREE.MeshStandardMaterial({color: 0xffae00}));
                b.position.set(sx, sy, -0.5);
                worldGroup.add(b);
                blocks.push(b);
                canAction = false;
                setTimeout(() => canAction = true, 500);
            }
        }
    });
});

// 4. ANIMATION & START
document.getElementById('start-btn').onclick = () => {
    document.getElementById('start-overlay').style.display = 'none';
    new Camera(document.getElementById("video"), {
        onFrame: async () => await hands.send({ image: document.getElementById("video") }),
        width: 1280, height: 720
    }).start();
};

function animate() {
    requestAnimationFrame(animate);
    snowSystem.position.y -= 0.01;
    if(snowSystem.position.y < -2) snowSystem.position.y = 2;
    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
