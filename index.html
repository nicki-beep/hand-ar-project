<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Architect OS - Dual Ghost Mode</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #video { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: -2; filter: grayscale(0.8) contrast(1.2); }
        #os-ui { position: fixed; top: 20px; left: 20px; color: #00ff00; z-index: 30; background: rgba(0, 40, 0, 0.6); padding: 15px; border: 1px solid #00ff00; pointer-events: none; }
        
        /* Progress Ring */
        #loader-svg {
            position: fixed; width: 100px; height: 100px; z-index: 100;
            transform: translate(-50%, -50%); display: none; pointer-events: none;
        }
        #loader-circle {
            fill: none; stroke: #00ff00; stroke-width: 6;
            stroke-dasharray: 283; stroke-dashoffset: 283;
            transition: stroke-dashoffset 0.1s linear;
        }
        #loader-bg { fill: none; stroke: rgba(0, 255, 0, 0.15); stroke-width: 6; }

        canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 1; }
        #start-btn { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; background: #000; color: #00ff00; border: 2px solid #00ff00; cursor: pointer; z-index: 200; font-size: 20px; font-weight: bold; }
    </style>
</head>
<body>

<button id="start-btn">BOOT ARCHITECT_OS</button>
<div id="os-ui">MODE: DUAL_GHOST<br>VOXELS: <span id="count">0</span></div>

<svg id="loader-svg" viewBox="0 0 100 100">
    <circle id="loader-bg" cx="50" cy="50" r="45"></circle>
    <circle id="loader-circle" cx="50" cy="50" r="45" transform="rotate(-90 50 50)"></circle>
</svg>

<video id="video" autoplay playsinline></video>

<script>
let scene, camera, renderer, worldGroup, buildGhost, eraseGhost, blocks = [];
let progressTimer = 0; 
const GRID = 0.6;

// 1. SCENE SETUP
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 4;
renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setClearColor(0x000000, 0); 
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

worldGroup = new THREE.Group();
scene.add(worldGroup);
scene.add(new THREE.AmbientLight(0xffffff, 2));

// BUILD GHOST (Red Wireframe)
buildGhost = new THREE.Mesh(new THREE.BoxGeometry(GRID, GRID, GRID), new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true }));
buildGhost.visible = false;
scene.add(buildGhost);

// ERASER GHOST (White Wireframe)
eraseGhost = new THREE.Mesh(new THREE.SphereGeometry(GRID/2, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true }));
eraseGhost.visible = false;
scene.add(eraseGhost);

// 2. HAND TRACKING
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8, selfieMode: true });

hands.onResults(results => {
    const loaderSvg = document.getElementById('loader-svg');
    const loaderCircle = document.getElementById('loader-circle');
    
    if (!results.multiHandLandmarks) {
        loaderSvg.style.display = 'none';
        progressTimer = 0;
        return;
    }

    let handData = { left: null, right: null };
    results.multiHandLandmarks.forEach((lm, i) => {
        const label = results.multiHandedness[i].label.toLowerCase();
        handData[label] = lm;
    });

    // LEFT HAND: OK sign = Build Ghost
    if (handData.left) {
        const isOK = Math.hypot(handData.left[4].x - handData.left[8].x, handData.left[4].y - handData.left[8].y) < 0.05;
        if (isOK) {
            buildGhost.visible = true;
            buildGhost.position.set((handData.left[8].x - 0.5) * 8, -(handData.left[8].y - 0.5) * 6, -1);
        } else { buildGhost.visible = false; }
    } else { buildGhost.visible = false; }

    // RIGHT HAND: Index only = Eraser Ghost
    if (handData.right) {
        const rIdx = handData.right[8];
        const rThumb = handData.right[4];
        const isPinch = Math.hypot(rIdx.x - rThumb.x, rIdx.y - rThumb.y) < 0.04;
        
        // Show Eraser Ghost if index is extended but not pinching
        if (!isPinch) {
            eraseGhost.visible = true;
            eraseGhost.position.set((rIdx.x - 0.5) * 8, -(rIdx.y - 0.5) * 6, -1);
            
            // Auto-erase blocks on touch
            let hitIdx = blocks.findIndex(b => b.position.distanceTo(eraseGhost.position) < 0.4);
            if (hitIdx !== -1) {
                worldGroup.remove(blocks[hitIdx]);
                blocks.splice(hitIdx, 1);
                document.getElementById('count').innerText = blocks.length;
            }
        } else { eraseGhost.visible = false; }

        // PINCH PROGRESS LOGIC
        if (isPinch && buildGhost.visible) {
            loaderSvg.style.display = 'block';
            loaderSvg.style.left = (handData.right[9].x * 100) + "%";
            loaderSvg.style.top = (handData.right[9].y * 100) + "%";
            
            progressTimer += 2; // ~1 second to fill
            loaderCircle.style.strokeDashoffset = 283 - (Math.min(progressTimer, 100) / 100 * 283);

            if (progressTimer >= 100) {
                const b = new THREE.Mesh(new THREE.BoxGeometry(GRID, GRID, GRID), new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 }));
                b.position.copy(buildGhost.position);
                worldGroup.add(b); blocks.push(b);
                document.getElementById('count').innerText = blocks.length;
                progressTimer = 0;
            }
        } else {
            if (progressTimer > 0) progressTimer = 0;
            loaderSvg.style.display = 'none';
        }
    }

    // BOTH HANDS GESTURES (Reset/Rotate)
    if (handData.left && handData.right) {
        const lPalm = handData.left[12].y < handData.left[9].y;
        const rPalm = handData.right[12].y < handData.right[9].y;
        if (lPalm && rPalm) worldGroup.rotation.y += 0.05;

        const lFist = Math.hypot(handData.left[8].x - handData.left[0].x) < 0.12;
        const rFist = Math.hypot(handData.right[8].x - handData.right[0].x) < 0.12;
        if (lFist && rFist) { 
            blocks.forEach(b => worldGroup.remove(b));
            blocks = []; 
            document.getElementById('count').innerText = "0";
        }
    }
});

const startBtn = document.getElementById('start-btn');
startBtn.onclick = () => {
    startBtn.style.display = 'none';
    new Camera(document.getElementById("video"), { onFrame: async () => await hands.send({image: video}), width: 1280, height: 720 }).start();
};
function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
animate();
</script>
</body>
</html>
