<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Architect OS - Perfect Mirror</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #video { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: -1; }
        #os-ui { position: fixed; top: 20px; left: 20px; color: #00ff00; z-index: 10; background: rgba(0, 40, 0, 0.7); padding: 15px; border: 1px solid #00ff00; pointer-events: none; }
        #start-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: #00ff00; }
        #start-btn { padding: 15px 30px; font-size: 18px; background: transparent; color: #00ff00; border: 2px solid #00ff00; cursor: pointer; visibility: hidden; }
        .ready { visibility: visible !important; }
        canvas#drawing_canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; transform: scaleX(-1); pointer-events: none; }
    </style>
</head>
<body>

<div id="start-overlay">
    <div id="loading-text">BIO_SYNC: CALIBRATING MIRROR...</div>
    <button id="start-btn">BOOT ARCHITECT</button>
</div>

<div id="os-ui">
    COLOR: <span id="color-name" style="color:white">GREEN</span><br>
    -------------------------<br>
    ü§è PINCH: PLACE | ‚úã PALM: ERASE<br>
    ‚úä 1 FIST: HOLD | ‚úä‚úä 2 FISTS: 360¬∞ ROTATE<br>
    ‚úåÔ∏è FLICK: COLOR | üôè: RESET
</div>

<video id="video" autoplay playsinline></video>
<canvas id="drawing_canvas"></canvas>

<script>
let scene, camera, renderer, worldGroup, previewBlock, blocks = [];
let canAction = true, canColorChange = true;
const GRID = 0.25;

// Color Cycle: Green, Blue, Red, Purple, Orange
const colors = [0x00ff00, 0x0000ff, 0xff0000, 0x800080, 0xffa500];
const colorNames = ["GREEN", "BLUE", "RED", "PURPLE", "ORANGE"];
let colorIdx = 0;

// 1. THREE.JS SETUP
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 3;
renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff, 1.2));

worldGroup = new THREE.Group();
scene.add(worldGroup);

previewBlock = new THREE.Mesh(new THREE.BoxGeometry(GRID, GRID, GRID), new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true }));
scene.add(previewBlock);

// 2. HAND OUTLINE SETUP
const drawCanvas = document.getElementById('drawing_canvas');
const drawCtx = drawCanvas.getContext('2d');

// 3. GESTURE LOGIC
const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.7 });

let lastFistPos = null;

hands.onResults(results => {
    // Clear Hand Outline Canvas
    drawCanvas.width = window.innerWidth;
    drawCanvas.height = window.innerHeight;
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);

    if (!results.multiHandLandmarks) return;

    let fists = [];
    const landmarks = results.multiHandLandmarks;

    landmarks.forEach((lm, i) => {
        // Draw Neon Outline 
        drawConnectors(drawCtx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
        drawLandmarks(drawCtx, lm, {color: '#FFFFFF', lineWidth: 1, radius: 3});

        const wrist = lm[0], thumb = lm[4], idx = lm[8], mid = lm[12], pky = lm[20];
        
        // MIRROR MATH: -1 on X ensures it follows your hand like a mirror
        const x = (idx.x - 0.5) * 5; 
        const y = -(idx.y - 0.5) * 3;

        const isFist = Math.hypot(idx.x-wrist.x, idx.y-wrist.y) < 0.15;
        const isPalm = Math.hypot(idx.y-wrist.y) > 0.3;
        const pinch = Math.hypot(idx.x-thumb.x, idx.y-thumb.y) < 0.05;
        const isPeace = Math.hypot(idx.y-mid.y) < 0.08 && idx.y < wrist.y;

        // Color Change (‚úåÔ∏è)
        if (isPeace && canColorChange) {
            colorIdx = (colorIdx + 1) % colors.length;
            previewBlock.material.color.setHex(colors[colorIdx]);
            document.getElementById('color-name').innerText = colorNames[colorIdx];
            canColorChange = false; setTimeout(() => canColorChange = true, 700);
        }

        if (isFist) fists.push({x, y});

        // HOLD & ROTATE
        if (fists.length === 1 && isFist) {
            if (lastFistPos) {
                worldGroup.position.x += (x - lastFistPos.x);
                worldGroup.position.y += (y - lastFistPos.y);
            }
            lastFistPos = {x, y};
        } else if (fists.length === 2) {
            worldGroup.rotation.y += 0.05;
        } else {
            lastFistPos = null;
        }

        // ERASE
        if (isPalm && !isFist && blocks.length > 0 && canAction) {
            const b = blocks.pop();
            worldGroup.remove(b);
            canAction = false; setTimeout(() => canAction = true, 500);
        }

        // PLACE
        if (pinch && canAction && !isFist) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(GRID, GRID, GRID), new THREE.MeshStandardMaterial({color: colors[colorIdx]}));
            const vector = new THREE.Vector3(Math.round(x/GRID)*GRID, Math.round(y/GRID)*GRID, -1);
            worldGroup.worldToLocal(vector);
            b.position.copy(vector);
            worldGroup.add(b); blocks.push(b);
            canAction = false; setTimeout(() => canAction = true, 500);
        }

        if (i === 0) previewBlock.position.set(Math.round(x/GRID)*GRID, Math.round(y/GRID)*GRID, -1);
    });

    // RESET (üôè)
    if (landmarks.length === 2) {
        if (Math.hypot(landmarks[0][0].x-landmarks[1][0].x) < 0.1) {
            blocks.forEach(b => worldGroup.remove(b));
            blocks = []; worldGroup.position.set(0,0,0); worldGroup.rotation.set(0,0,0);
        }
    }
});

// BOOT ENGINE
const startBtn = document.getElementById('start-btn');
hands.initialize().then(() => startBtn.classList.add('ready'));
startBtn.onclick = () => {
    document.getElementById('start-overlay').style.display = 'none';
    new Camera(document.getElementById("video"), { 
        onFrame: async () => await hands.send({image: document.getElementById("video")}), 
        width: 1280, height: 720 
    }).start();
};
function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
animate();
</script>
</body>
</html>
